package main

/*
	cgo让我们可以在Go代码中使用C中的类型、变量和函数, 但Go的这种经由cgo与C
	代码互操作的行为不是无成本的; 主要有这几张开销:
	- 不能忽视的调用开销
		./cgo_call.go, ./cgo_call_test.go
	- 增加线程数量暴涨的可能性
		./go_sleep.go, ./cgo_sleep.go
	- 失去跨平台交叉构建能力
		./build.go
	- 其他开销
		Go代码与C代码分别位于两个世界, 它们无法很好地利用对方的优势;
		首先是内存管理, Go世界采用垃圾回收机制, 而C世界采用手工内存管理,
		开发人员在GC与"记着释放内存"的规则间切换, 极易产生bug, 给开发人
		员带来很大心智负担;
		Go所拥有的强大工具链在C代码面前无处施展, Go的竞态检测工具、
		性能剖析工具、测试覆盖率工具、模糊测试以及源码竞态分析工具再强大,
		也无法跨越Go与C之间的屏障; Go工具无法轻易访问C世界代码, 这使得代
		码调试更加困难; 辅助调试的运行时信息、行号、堆栈跟踪等信息一旦跨
		越屏障便消失得无影无踪;
*/
